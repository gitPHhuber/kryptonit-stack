---
- name: Offline deploy from local image archives
  hosts: all
  become: true
  gather_facts: true
  vars_files:
    - vars/offline.yml
  vars:
    offline_mode: "{{ (mode | default('run')) | lower }}"

  pre_tasks:
    - name: Validate requested execution mode
      ansible.builtin.assert:
        that:
          - offline_mode in ['load', 'run']
        fail_msg: "mode must be either 'load' or 'run'."

    - name: Check docker binary availability
      ansible.builtin.command: docker --version
      register: offline_docker_cli
      changed_when: false
      failed_when: false

    - name: Abort when Docker CLI is missing
      ansible.builtin.fail:
        msg: >-
          Docker CLI is unavailable. Install Docker Engine before running
          offline-run.
      when: offline_docker_cli.rc != 0

    - name: Check docker compose plugin availability
      ansible.builtin.command: docker compose version
      register: offline_docker_compose
      changed_when: false
      failed_when: false

    - name: Abort when Docker Compose plugin is missing
      ansible.builtin.fail:
        msg: >-
          Docker Compose plugin is unavailable.
          Install the docker-compose-plugin package or enable compose v2 before
          running offline-run. Offline mode requires Compose v2 to be available.
        when: offline_docker_compose.rc != 0

    - name: Check docker daemon status
      ansible.builtin.command: docker info
      register: offline_docker_info
      changed_when: false
      failed_when: false

    - name: Abort when docker daemon is not running
      ansible.builtin.fail:
        msg: >-
          Docker daemon is not running. Start the Docker service (for example,
          'sudo systemctl start docker') before running offline-run.
      when: offline_docker_info.rc != 0

    - name: Ensure offline image directory exists
      ansible.builtin.file:
        path: "{{ offline_images_dir }}"
        state: directory
        mode: '0755'

    - name: Detect offline manifest
      ansible.builtin.stat:
        path: "{{ offline_images_dir.rstrip('/') }}/manifest.json"
      register: offline_manifest_stat

    - name: Read offline manifest
      ansible.builtin.slurp:
        path: "{{ offline_images_dir.rstrip('/') }}/manifest.json"
      register: offline_manifest_raw
      when: offline_manifest_stat.stat.exists

    - name: Parse offline manifest entries
      ansible.builtin.set_fact:
        offline_manifest_entries: >-
          {{ offline_manifest_raw.content | b64decode | from_json }}
      when: offline_manifest_stat.stat.exists

  tasks:
    - name: Select offline image definitions
      ansible.builtin.set_fact:
        images_to_load_initial: >-
          {{
            (offline_manifest_entries | default([]))
            if ((offline_manifest_entries | default([])) | length > 0)
            else (offline_archives | default([]))
          }}

    - name: Fail when no offline image archives are defined
      ansible.builtin.fail:
        msg: >-
          No images specified. Provide manifest.json in
          {{ offline_images_dir }} or define offline_archives.
      when: images_to_load_initial | length == 0

    - name: Build image list with resolved archive paths
      ansible.builtin.set_fact:
        images_to_load: >-
          {% set resolved = [] %}
          {% for item in images_to_load_initial %}
          {%   set archive_source = item.archive | mandatory %}
          {%   set archive_path = (
                 archive_source
                 if archive_source.startswith('/')
                 else offline_images_dir.rstrip('/') ~ '/' ~
                      (archive_source | basename)
               ) %}
          {%   set _ = resolved.append(item | combine({
                   'archive_path': archive_path,
                   'image': item.image | mandatory
                 })) %}
          {% endfor %}
          {{ resolved }}

    - name: Ensure offline image archives exist
      ansible.builtin.stat:
        path: "{{ item.archive_path }}"
      loop: "{{ images_to_load }}"
      loop_control:
        label: "{{ item.archive_path }}"
      register: offline_archive_stats

    - name: Abort when an expected archive is missing
      ansible.builtin.fail:
        msg: >-
          Offline image archive {{ item.item.archive_path }} for
          {{ item.item.image }} is missing.
      loop: "{{ offline_archive_stats.results }}"
      loop_control:
        label: "{{ item.item.archive_path }}"
      when: not item.stat.exists

    - name: Load offline Docker images  # noqa args[module]
      community.docker.docker_image:
        name: "{{ item.image }}"
        source: load
        load_path: "{{ item.archive_path }}"
        state: present
        force_source: false
      loop: "{{ images_to_load }}"
      loop_control:
        label: "{{ item.image }}"

    - name: Deploy Kryptonit stack from offline images
      when: offline_mode == 'run'
      block:
        - name: Configure Docker network
          when: "'infra' in group_names"
          ansible.builtin.include_role:
            name: network

        - name: Deploy private CA
          when: "'infra' in group_names"
          ansible.builtin.include_role:
            name: private_ca

        - name: Deploy Caddy reverse proxy
          when: "'infra' in group_names"
          ansible.builtin.include_role:
            name: caddy

        - name: Deploy Authentik
          when: "'infra' in group_names"
          ansible.builtin.include_role:
            name: authentik

        - name: Deploy Nextcloud
          when: "'infra' in group_names"
          ansible.builtin.include_role:
            name: nextcloud

        - name: Deploy OnlyOffice
          when: "'infra' in group_names"
          ansible.builtin.include_role:
            name: onlyoffice
